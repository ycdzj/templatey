\documentclass[twoside, UTF8]{article}

%\usepackage{showframe}

\usepackage{geometry}
\geometry{left = 1.5cm, right = 1.5cm, top = 2.0cm, bottom = 1.0cm}

\usepackage{listings}
\usepackage{color}
\usepackage{courier}
\renewcommand\lstlistingname{} % Change language of section name
\lstset{ % General setup for the package
	language=C++,
	frame=tb,
	basicstyle=\small\ttfamily,
	keywordstyle=\color{blue},
	numbers=left,
%	numbersep=5pt,
	numberstyle=\tiny,
	tabsize=4,
	breaklines=true,
	postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}},
	showstringspaces=false	
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO, LE]{\leftmark}
\fancyhead[LO, RE]{\thepage}

\usepackage{afterpage}
\newcommand\blankpage{ \null\thispagestyle{empty}\addtocounter{page}{-1}\newpage }

\usepackage{ctex}
%\usepackage{CJK}

\title{Standard Code Library}
\author{}


\begin{document}
%	\begin{CJK}{UTF8}{gkai}
	\pagenumbering{gobble}
	\maketitle
	\afterpage{\blankpage}

	\newpage
	\tableofcontents

	\newpage
	\pagenumbering{arabic}
	\section{String algorithm}
		\subsection{Kmp}
			\lstinputlisting{../src/String/Kmp.cpp}
		\subsection{Longest Palindrome}
			\lstinputlisting{../src/String/Manacher.cpp}
		\subsection{Extend Kmp}
			\lstinputlisting{../src/String/ExKmp.cpp}
		\subsection{AC Automaton}
			\lstinputlisting{../src/String/ACAutomaton.cpp}
		\subsection{Suffix Arrary}
			\lstinputlisting{../src/String/SuffixArray.cpp}
	\newpage
	\section{Data Structure}
		\subsection{Basic ZKW}
			\begin{flushleft}
				经典的zkw神树，堆式存储结构，根节点为1，无论是时间还是空间都非常优秀。
				\linebreak 但zkw线段树难以像递归线段树那样进行大魔改。
				\linebreak 使用方法：init --> [] --> build --> query/update
				\linebreak op需要满足：结合律、交换律。
			\end{flushleft}
			\lstinputlisting{../src/DataStructure/basic_zkw.cpp}
		\subsection{Segment Tree}
			\begin{flushleft}
				线段树（点树）可以说是十分精妙的数据结构了。这里仅给出线段树的一种设计模式，线段树的适用范围十分广泛，应当根据不同的要求，设计出不同的线段树。
				\begin{itemize}
					\item 节点的值：存储什么样的值才能快速完成各项操作。
					\item merge：两个节点（线段）的合并。
					\item pushdown：将节点的某个值下推到孩子（进行等价转化）。
				\end{itemize}
			\end{flushleft}
			\lstinputlisting{../src/DataStructure/range_SegmentTree.cpp}
		\subsection{Binary Indexed Tree}
			\begin{flushleft}
				树状数组或许没啥用……
				\linebreak 能干的事zkw线段树应当也能干，码量也差不多
				\linebreak 而且按照zkw的说法，这两种东西其实是等价的，只不过遍历的方式不同而已
				\linebreak lowbit在某些场合（比如状压dp）可以优化一下常数，这个有用
			\end{flushleft}
			\lstinputlisting{../src/DataStructure/BIT.cpp}
		\subsection{Treap}
			\begin{flushleft}
				写得OOP了一些，可以适应更多种情况，用了STL的allocator，性能没有下降太多。与一般log算法相比，常数大约要乘以2。
				\linebreak 初始时仅需创建空指针（在这里即是一棵空树），大部分接口传入的都是指针的引用。
				\linebreak 为了进一步降低常数，没有使用构造函数。(experimental)
				\linebreak 实现的接口：size, insert, remove, select, lower\_bound, upper\_bound, contain
			\end{flushleft}
			\lstinputlisting{../src/DataStructure/Treap.cpp}
		\subsection{Splay Tree}
			\lstinputlisting{../src/DataStructure/SplayTree.cpp}
	\newpage
	\section{Graph}
		\subsection{Maximum Flow}
			\begin{flushleft}
				最大流的dinic算法，每次先在残量网络中bfs构建层次图（level），再dfs寻找增广路。
				\linebreak dfs中用到了当前边优化技巧。
				\linebreak 每次add\_edge的时候都一次加两条，这样可以方便地找到反向边。
			\end{flushleft}
			\lstinputlisting{../src/Graph/dinic.cpp}
			
		\newpage
		\subsection{Maximum Bipartite Matching}
			\begin{flushleft}
				求二分图最大匹配的匈牙利算法，单向边和双向边都适用。
				\linebreak 这个和求二分图最大匹配的网络流模型还是很像的，
				\linebreak 每次dfs寻找一条未匹配/已匹配边交错出现的路径（与寻找一条网络流模型中的增广路等价）。
			\end{flushleft}
			\begin{itemize}
				\item For any bipartite graph, $|$Maximum Matching$|$ == $|$Minimum Vertex Cover$|$
				\item For any graph, $|$Minimum Edge Cover$|$ == $|$V$|$ - $|$Maximum Matching$|$
				\item DAG的最小路径覆盖：用最少的路径覆盖所有点，且每个点仅属于一条路径。方法：拆点拆成二分图，跑最大匹配。
				\item HALL's theory
			\end{itemize}
			\lstinputlisting{../src/Graph/Maximum_Matching.cpp}
		\newpage
		\subsection{Cut and Bridge and BCC}
			\begin{flushleft}
				求\textbf{无向图}的割点、割边（桥）、点双连通分量的tarjan算法，使用了dfn和low。
				\linebreak bcc编号从1开始。
			\end{flushleft}
			\lstinputlisting{../src/Graph/cut_bridge.cpp}
			\begin{itemize}
				\item $u$ $is$ $a$ $cut$ $\Leftrightarrow \exists v, <u, v> \in T \wedge Min[v] == d[u]$
				\item $pre$ $is$ $a$ $bridge$ $\Leftrightarrow Min[u] == d[u] - 1 \wedge \forall <u, v> \in T, Min[v] == d[u]$
			\end{itemize}
		\newpage
		\subsection{Strongly Connected Components}
			\begin{flushleft}
				tarjan的求强连通分量算法，还是使用dfn和low，只用树边和后向边更新low，不管cross-edge。
				\linebreak u是其所在scc的第一个被搜到的点，当且仅当$low[u] == dfn[u]$
				\linebreak scc编号从1开始。
			\end{flushleft}
			\lstinputlisting{../src/Graph/scc.cpp}
	\newpage
	\section{2D Geometry}
		\subsection{Basic Operations}
			\begin{flushleft}
				计算几何中向量的基本操作，大致分为：加减、数乘（除）、点积（dot）、叉积（cross）、旋转、求长度、求单位向量，同时把点也当作向量。
				\linebreak 参数不一定要传引用，成员只有两个double也快不了多少。尽量不用构造函数，太慢了。。
			\end{flushleft}
			\lstinputlisting{"../src/Geometry/2D Basic.cpp"}
		\subsection{Circle}
			\begin{flushleft}
				和圆有关的一些操作
				\linebreak 求两圆的交点是训练指南上的板子，返回交点个数，结果放在res中
			\end{flushleft}
			\lstinputlisting{"../src/Geometry/Circle.cpp"}
	\newpage
	\section{Number Theory}
		\subsection{Prime Number}
			\begin{flushleft}
				素数筛，$a[i]$代表$i$的素因子分解式中最小的素数。
			\end{flushleft}
			\lstinputlisting{../src/Math/prime.cpp}
		\subsection{Extend Euclid}
			\lstinputlisting{../src/Math/euclid.cpp}
	\newpage
	\section{Other}
		\subsection{Checker}
			\lstinputlisting[language=sh]{../src/Other/checker.sh}
		\subsection{Fast IO}
			\lstinputlisting{../src/Other/FastIO.cpp}
%\end{CJK}
\end{document}

\newpage
\section{Data Structure}
	\subsection{Basic ZKW}
		\begin{flushleft}
			\begin{itemize}
				\item 根节点为1，$[1, n)$是内部结点，$[n, 2n)$是叶结点，+n快速找到叶子
				\item op需要满足：结合律、交换律
			\end{itemize}
		\end{flushleft}
		\lstinputlisting{Sections/DataStructure/basic_zkw.cpp}
	\newpage
	\subsection{Segment Tree}
		\begin{flushleft}
			线段树设计模式：
			\begin{itemize}
				\item 节点的值：存储什么样的信息才能快速完成各项操作。
				\item pushdown：把节点的信息等价转化给孩子（将更改下推）。
				\item merge：把两个节点合并（根据下层的值构造上层的值）。
			\end{itemize}
			下面给出一个例子，实现了区间更改/区间查询最小值的功能。
		\end{flushleft}
		\lstinputlisting{Sections/DataStructure/SegmentTree.cpp}
	\newpage
	\subsection{Persistent Segment Tree}
		\begin{flushleft}
			\begin{itemize}
				\item 初学Persistent DS, MIT的公开课还没看明白。
				\item pointer machine
				\item version
				\item partial / full persistent, thinking / method / analysis
			\end{itemize}
			下面是一棵支持单点修改、区间求和的持久化线段树。
		\end{flushleft}
		\lstinputlisting{Sections/DataStructure/psgt.cpp}
	\newpage
	\subsection{Binary Indexed Tree}
		\begin{flushleft}
			\begin{itemize}
				\item 下标范围$[1, n]$
				\item 第i个位置存放原数组以$a_{i}$为最后一个元素的$lowbit(i)$个元素的和
				\item $lowbit$可用来快速查找二进制表示中最低位的1
			\end{itemize}
		\end{flushleft}
		\lstinputlisting{Sections/DataStructure/BIT.cpp}
	\newpage
	\subsection{Treap}
		\begin{flushleft}
			初始时仅需创建空指针（即一棵空树），大部分接口传入的都是指针的引用。
			\linebreak 实现的接口：size, insert, remove, select, lower\_bound, upper\_bound, contain
			\linebreak \textbf{***瞎搞警告***}
			\linebreak \textbf{***大常数警告***}
		\end{flushleft}
		\lstinputlisting{Sections/DataStructure/Treap.cpp}
	\newpage
	\subsection{Splay Tree}
		\begin{flushleft}
			可分割/合并序列可用std::rope完成。
		\end{flushleft}
		\lstinputlisting{Sections/DataStructure/SplayTree.cpp}
